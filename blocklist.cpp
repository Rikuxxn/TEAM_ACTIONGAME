//=============================================================================
//
// ブロックリスト処理 [blocklist.cpp]
// Author : RIKU TANEKAWA
//
//=============================================================================

//*****************************************************************************
// インクルードファイル
//*****************************************************************************
#include "blocklist.h"
#include "blockmanager.h"
#include "player.h"
#include "game.h"
#include "manager.h"
#include "particle.h"
#include <algorithm>

// 名前空間stdの使用
using namespace std;

//=============================================================================
// 木箱ブロックのコンストラクタ
//=============================================================================
CWoodBoxBlock::CWoodBoxBlock()
{
	// 値のクリア
	m_ResPos = INIT_VEC3;// リスポーン位置
}
//=============================================================================
// 木箱ブロックのデストラクタ
//=============================================================================
CWoodBoxBlock::~CWoodBoxBlock()
{
	// なし
}
//=============================================================================
// 木箱ブロックの初期化処理
//=============================================================================
HRESULT CWoodBoxBlock::Init(void)
{
	// ブロックの初期化処理
	CBlock::Init();

	// 最初の位置をリスポーン位置に設定
	m_ResPos = GetPos();

	// 動的に戻す
	SetEditMode(false);

	return S_OK;
}
//=============================================================================
// 木箱ブロックの更新処理
//=============================================================================
void CWoodBoxBlock::Update()
{
	CBlock::Update(); // 共通処理
}
//=============================================================================
// リスポーン処理
//=============================================================================
void CWoodBoxBlock::Respawn(D3DXVECTOR3 resPos)
{
	// 動かすためにキネマティックにする
	SetEditMode(true);

	// 水しぶきパーティクル生成
	CParticle::Create<CWaterParticle>(INIT_VEC3, GetPos(), D3DXCOLOR(0.3f, 0.6f, 1.0f, 0.8f), 50, 10);
	CParticle::Create<CWaterParticle>(INIT_VEC3, GetPos(), D3DXCOLOR(0.3f, 0.5f, 1.0f, 0.5f), 50, 10);

	// リスポーン位置に設定
	SetPos(resPos);
	SetRot(D3DXVECTOR3(0.0f, 0.0f, 0.0f));

	// コライダーの更新
	UpdateCollider();

	// 動的に戻す
	SetEditMode(false);
}
//=============================================================================
// セット処理
//=============================================================================
void CWoodBoxBlock::Set(D3DXVECTOR3 pos)
{
	// 動かすためにキネマティックにする
	SetEditMode(true);

	// 鍵ブロックの位置を取得
	D3DXVECTOR3 Pos = GetPos();
	D3DXVECTOR3 Rot = GetRot();

	D3DXVECTOR3 targetPos(pos);			// 設置する目標位置
	D3DXVECTOR3 rot(0.0f, 0.0f, 0.0f);	// 向きをリセット

	Pos = targetPos;
	Rot = rot;

	SetPos(Pos);
	SetRot(Rot);

	// コライダーの更新
	UpdateCollider();
}


//=============================================================================
// シーソーブロックのコンストラクタ
//=============================================================================
CSeesawBlock::CSeesawBlock()
{
	// 値のクリア
	m_pHinge = nullptr;
}
//=============================================================================
// シーソーブロックのデストラクタ
//=============================================================================
CSeesawBlock::~CSeesawBlock()
{
	// なし
}
//=============================================================================
// シーソーブロックの初期化処理
//=============================================================================
HRESULT CSeesawBlock::Init(void)
{
	// ブロックの初期化処理
	CBlock::Init();

	return S_OK;
}
//=============================================================================
// シーソーブロックの終了処理
//=============================================================================
void CSeesawBlock::Uninit(void)
{
	if (m_pHinge)
	{
		CManager::GetPhysicsWorld()->removeConstraint(m_pHinge);
		delete m_pHinge;
		m_pHinge = nullptr;
	}

	// ブロックの終了処理
	CBlock::Uninit();
}
//=============================================================================
// シーソーブロックのヒンジ削除処理
//=============================================================================
void CSeesawBlock::RemoveHinge(void)
{
	if (m_pHinge)
	{
		// ワールドから削除
		CManager::GetPhysicsWorld()->removeConstraint(m_pHinge);
		delete m_pHinge;
		m_pHinge = nullptr;
	}
}
//=============================================================================
// シーソーブロックの更新処理
//=============================================================================
void CSeesawBlock::Update(void)
{
	// ブロックの更新処理
	CBlock::Update();
}
//=============================================================================
// シーソーブロックのヒンジ設定処理
//=============================================================================
void CSeesawBlock::SetHinge(void)
{
	// リジッドボディの取得
	btRigidBody* pRigid = GetRigidBody();

	if (!pRigid)
	{// nullだったら
		return;
	}

	// rigidbody の transform を取得
	btTransform transform;
	if (pRigid->getMotionState())
	{
		pRigid->getMotionState()->getWorldTransform(transform);
	}
	else
	{
		transform = pRigid->getCenterOfMassTransform();
	}

	// Z軸をローカル軸としてヒンジに設定
	btVector3 localLongAxis(0, 0, 1);

	btVector3 pivot(0, 0, 0); // ヒンジのピボット（ブロック中心）

	// ヒンジ作成（ローカル空間軸）
	m_pHinge = new btHingeConstraint(*pRigid, pivot, localLongAxis, true);

	// 回転制限
	m_pHinge->setLimit(-SIMD_RADS_PER_DEG * 30.0f, SIMD_RADS_PER_DEG * 30.0f);

	// ワールドに追加
	CManager::GetPhysicsWorld()->addConstraint(m_pHinge, true);
}


//=============================================================================
// ギアブロックのコンストラクタ
//=============================================================================
CGearBlock::CGearBlock()
{
	// 値のクリア
}
//=============================================================================
// ギアブロックのデストラクタ
//=============================================================================
CGearBlock::~CGearBlock()
{
	// 無し
}
//=============================================================================
// ギアブロックの更新処理
//=============================================================================
void CGearBlock::Update(void)
{
	// ブロックの更新処理
	CBlock::Update();

	D3DXVECTOR3 playerPos = CGame::GetPlayer()->GetPos();
	D3DXVECTOR3 disPos = playerPos - GetPos();
	float distance = D3DXVec3Length(&disPos);
	const float kTriggerDistance = 580.0f; // 反応距離

	if (distance < kTriggerDistance)
	{
		// 回転
		D3DXVECTOR3 rot = GetRot();

		rot.y += 0.02f;// 回転スピード

		// 正規化
		if (rot.y > D3DX_PI)
		{
			rot.y -= D3DX_PI * 2.0f;
		}
		else if (rot.y <= -D3DX_PI)
		{
			rot.y += D3DX_PI * 2.0f;
		}

		// 向きの設定
		SetRot(rot);
	}

}


//=============================================================================
// ギア柱ブロックのコンストラクタ
//=============================================================================
CGearPillarBlock::CGearPillarBlock()
{
	// 値のクリア
}
//=============================================================================
// ギア柱ブロックのデストラクタ
//=============================================================================
CGearPillarBlock::~CGearPillarBlock()
{
	// 無し
}
//=============================================================================
// ギア柱ブロックの更新処理
//=============================================================================
void CGearPillarBlock::Update(void)
{
	// ブロックの更新処理
	CBlock::Update();

}


//=============================================================================
// プレスブロックのコンストラクタ
//=============================================================================
CPressBlock::CPressBlock()
{
	// 値のクリア
}
//=============================================================================
// プレスブロックのデストラクタ
//=============================================================================
CPressBlock::~CPressBlock()
{
	// なし
}
//=============================================================================
// プレスブロックの初期化処理
//=============================================================================
HRESULT CPressBlock::Init(void)
{
	// ブロックの初期化処理
	CBlock::Init();

	return S_OK;
}
//=============================================================================
// プレスブロックの更新処理
//=============================================================================
void CPressBlock::Update(void)
{
	// ブロックの更新処理
	CBlock::Update();

}


//=============================================================================
// プロペラボディブロックのコンストラクタ
//=============================================================================
CPropellerBodyBlock::CPropellerBodyBlock()
{
	// 値のクリア
}
//=============================================================================
// プロペラボディブロックのデストラクタ
//=============================================================================
CPropellerBodyBlock::~CPropellerBodyBlock()
{
	// なし
}
//=============================================================================
// プロペラボディブロックの更新処理
//=============================================================================
void CPropellerBodyBlock::Update(void)
{
	// ブロックの更新処理
	CBlock::Update();

}


//=============================================================================
// プロペラ羽ブロックのコンストラクタ
//=============================================================================
CPropellerWingBlock::CPropellerWingBlock()
{
	// 値のクリア
}
//=============================================================================
// プロペラ羽ブロックのデストラクタ
//=============================================================================
CPropellerWingBlock::~CPropellerWingBlock()
{
	// なし
}
//=============================================================================
// プロペラ羽ブロックの更新処理
//=============================================================================
void CPropellerWingBlock::Update(void)
{
	// ブロックの更新処理
	CBlock::Update();

}
